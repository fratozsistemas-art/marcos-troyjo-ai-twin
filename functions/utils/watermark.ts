// Watermarking utilities for AI-generated content
import { createClientFromRequest } from 'npm:@base44/sdk@0.8.4';

function generateWatermarkId() {
    return `WM-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Invisible Unicode watermark technique
function embedInvisibleWatermark(text, watermarkId) {
    // Use zero-width characters to embed ID
    const zeroWidthChars = ['\u200B', '\u200C', '\u200D', '\u2060'];
    
    const binary = watermarkId.split('').map(char => 
        char.charCodeAt(0).toString(2).padStart(8, '0')
    ).join('');
    
    const watermark = binary.split('').map(bit => 
        zeroWidthChars[parseInt(bit, 10) * 2]
    ).join('');
    
    // Embed at multiple locations for redundancy
    const segments = Math.ceil(text.length / 4);
    let watermarkedText = text;
    
    for (let i = 1; i <= 3; i++) {
        const pos = segments * i;
        if (pos < text.length) {
            watermarkedText = watermarkedText.slice(0, pos) + watermark + watermarkedText.slice(pos);
        }
    }
    
    return watermarkedText;
}

// Visible metadata watermark
function addMetadataWatermark(text, metadata) {
    const footer = `\n\n---\n*Generated by Troyjo Digital Twin | ${metadata.date} | ID: ${metadata.id.substr(0, 8)}*`;
    return text + footer;
}

export async function watermarkContent(req, content, contentType = 'conversation') {
    try {
        const base44 = createClientFromRequest(req);
        const user = await base44.auth.me();
        
        const watermarkId = generateWatermarkId();
        const metadata = {
            id: watermarkId,
            user: user?.email || 'anonymous',
            date: new Date().toISOString(),
            type: contentType
        };
        
        // Log watermark creation
        await base44.asServiceRole.entities.ContentWatermark.create({
            watermark_id: watermarkId,
            user_email: user?.email || 'anonymous',
            content_type: contentType,
            created_at: metadata.date,
            ip_address: req.headers.get('x-forwarded-for') || 'unknown'
        });
        
        // Apply both invisible and visible watermarks
        let watermarkedContent = embedInvisibleWatermark(content, watermarkId);
        watermarkedContent = addMetadataWatermark(watermarkedContent, metadata);
        
        return {
            content: watermarkedContent,
            watermarkId,
            metadata
        };
    } catch (error) {
        console.error('Watermarking failed:', error);
        return { content, watermarkId: null, metadata: null };
    }
}

export function extractWatermark(text) {
    // Attempt to extract invisible watermark
    const zeroWidthChars = ['\u200B', '\u200C', '\u200D', '\u2060'];
    const found = text.split('').filter(char => zeroWidthChars.includes(char));
    
    if (found.length > 0) {
        try {
            const binary = found.map(char => 
                zeroWidthChars.indexOf(char) > 1 ? '1' : '0'
            ).join('');
            
            const chars = binary.match(/.{8}/g)?.map(byte => 
                String.fromCharCode(parseInt(byte, 2))
            ).join('') || '';
            
            return chars;
        } catch (error) {
            console.error('Watermark extraction failed:', error);
        }
    }
    
    // Try to extract from visible metadata
    const metadataMatch = text.match(/ID: ([a-zA-Z0-9]+)/);
    return metadataMatch ? metadataMatch[1] : null;
}